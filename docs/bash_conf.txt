#### etc/bash/00-bashrc.before.sh
## 00-bashrc.before.sh     -- bash dotfiles configuration root
#  source ${__DOTFILES}/etc/bash/00-bashrc.before.sh    -- dotfiles_reload()
#
  #  dotfiles_reload()  -- (re)load the bash configuration
  #  $__DOTFILES (str): -- path to the dotfiles symlink (~/.dotfiles)
  #
  ## 01-bashrc.lib.sh           -- useful bash functions (paths)
  #  lspath()           -- list every file along $PATH
  #  realpath()         -- readlink -f (python os.path.realpath)
  #  walkpath()         -- list every directory along ${1:-"."}
  #
  ## 02-bashrc.platform.sh      -- platform things
  #  detect_platform()  -- set $__IS_MAC or $__IS_LINUX 
  #
  ## 03-bashrc.readline.sh      -- readline
  #
  ## 04-bashrc.TERM.sh          -- set $TERM and $CLICOLOR
  #
  ## 05-bashrc.dotfiles.sh      -- dotfiles
  #  $__DOTFILES (str): -- path to the dotfiles symlink (~/.dotfiles)
  #  dotfiles_status()  -- print dotfiles variables
  #  ds()               -- print dotfiles variables
  #
  ## 06-bashrc.completion.sh    -- configure bash completion
  #
  #  python: pip, virtualenv, virtualenvwrapper
  #  $PROJECT_HOME (str): path to project directory (~/wrk)
  #  $WORKON_HOME  (str): path to virtualenvs directory (~/wrk/.ve)
  #  $VIRTUAL_ENV  (str): path to current $VIRTUAL_ENV
  #
  ## 07-bashrc.python.sh        -- python
  #  _setup_anaconda()  -- setup anaconda paths (manual)
  #  _setup_pyenv()     -- setup pyenv paths (manual)
  #
  ## 07-bashrc.virtualenvwrapper.sh -- virtualenvwrapper
  #
  ## 08-bashrc.gcloud.sh        -- gcloud: Google Cloud SDK
  #  _setup_google_cloud()  -- setup google cloud paths
  #
  ## 10-bashrc.venv.sh          -- venv: virtualenvwrapper extensions
  #  $__PROJECTSRC     (str): script to source (${PROJECT_HOME}/.projectsrc.sh)
  #  $VIRTUAL_ENV_NAME (str): basename of current $VIRTUAL_ENV
  #  $_APP             (str): $VIRTUAL_ENV/src/${_APP}
  #  we() -- workon a new venv
  #     $1: VIRTUAL_ENV_NAME [$WORKON_HOME/${VIRTUAL_ENV_NAME}=$VIRTUAL_ENV]
  #     $2: _APP (optional; defaults to $VIRTUAL_ENV_NAME)
  #     we dotfiles
  #     we dotfiles etc/bash; cdw; ds; ls
  #
  #
  ## 11-bashrc.venv.pyramid.sh  -- venv-pyramid: pyramid-specific config
  #
  ## 20-bashrc.editor.sh        -- $EDITOR configuration
  #  $_EDIT_ (str): cmdstring to open $@ (file list) in current editor
  #  $EDITOR (str): cmdstring to open $@ (file list) in current editor
  ## 20-bashrc.vimpagers.sh     -- $PAGER configuration
  #  $PAGER (str): cmdstring to run pager (less/vim)
  #
  ## 30-bashrc.usrlog.sh        -- $_USRLOG configuration
  #  $_USRLOG (str): path to .usrlog command log
  #  stid       -- set $TERM_ID to a random string
  #  stid $name -- set $TERM_ID to string
  #  note       -- add a dated note to $_USRLOG [_usrlog_append]
  #  usrlogv    -- open usrlog with vim:   $VIMBIN + $_USRLOG
  #  usrlogg    -- open usrlog with gmvim: $GUIVIMBIN + $_USRLOG
  #  usrloge    -- open usrlog with editor:$EDITOR + $_USRLOG
  #  ut         -- tail $_USRLOG
  #  ug         -- egrep current usrlog: egrep $@ $_USRLOG
  #  ugall      -- egrep $@ $__USRLOG ${WORKON_HOME}/*/.usrlog
  #  ugrin      -- grin current usrlog: grin $@ $_USRLOG
  #  ugrinall   -- grin $@  $__USRLOG ${WORKON_HOME}/*/.usrlog
  #  lsusrlogs  -- ls -tr   $__USRLOG ${WORKON_HOME}/*/.usrlog
  #
  ## 30-bashrc.xlck.sh          -- screensaver, (auto) lock, suspend
  #
  ## 40-bashrc.aliases.sh       -- aliases
  ## 42-bashrc.commands.sh      -- example commands
  #
  ## 50-bashrc.bashmarks.sh     -- bashmarks: local bookmarks
  #
  ## 70-bashrc.repos.sh         -- repos: $__SRC repos, docs
  #
  ## 99-bashrc.after.sh         -- after: cleanup
    # dr()  -- dotfiles_reload
    # ds()  -- print dotfiles_status()
   
   
#### etc/bash/01-bashrc.lib.sh
### bashrc.lib.sh
## bash
    # echo_args         -- echo $@ (for checking quoting)
    # function_exists() -- check whether a bash function exists
    # add_to_path       -- prepend a directory to $PATH
    #   instead of:
    #       export PATH=$dir:$PATH
    #       add_to_path $dir 
    # lightpath()       -- display $PATH with newlines
    # lspath()          -- list files in each directory in $PATH
    # lspath_less()     -- lspath with less (color)
## file paths
    # realpath()        -- print absolute path (os.path.realpath) to $1
    #                      note: OSX does not have readlink -f
    # path()            -- realpath()
    # walkpath()        -- walk down path $1 and $cmd each component
    #   $1: path (optional; default: pwd)
    #   $2: cmd  (optional; default: 'ls -ald --color=auto')
    # ensure_symlink()  -- create or update a symlink to $2 from $1
    #                      if $2 exists, backup with suffix $3
    # ensure_mkdir()    -- create directory $1 if it does not yet exist
   
   
#### etc/bash/02-bashrc.platform.sh
### bashrc.platform.sh
    # detect_platform() -- set $__IS_MAC or $__IS_LINUX according to $(uname)
   
   
#### etc/bash/03-bashrc.readline.sh
### bashrc.readline.sh
    # set -o vi -- vi-mode: vi keyboard shortcuts
    # .         -- insert last argument (command mode)
    # emulate default bash:
    # <ctrl> l  -- clear screen
    # <ctrl> a  -- move to beginning of line (^)
    # <ctrl> e  -- move to end of line ($)
    # <ctrl> w  -- delete last word
   
   
#### etc/bash/04-bashrc.TERM.sh
### bashrc.TERM.sh
    # configure_TERM            -- configure the $TERM variable (man terminfo)
    #   $1: (optional; autodetects if -z)
    # configure_TERM_CLICOLOR   -- configure $CLICOLOR and $CLICOLOR_256
    #   CLICOLOR=1
    # configure_TERM when sourced
   
   
#### etc/bash/05-bashrc.dotfiles.sh
### bashrc.dotfiles.sh
    # dotfiles_add_path()       -- add ${__DOTFILES}/scripts to $PATH
    # dotfiles_status()         -- print dotfiles_status
    # ds()                      -- print dotfiles_status
    # log_dotfiles_state()      -- save current environment to logfiles
    # dotfiles_initialize()     -- virtualenvwrapper initialize
    # dotfiles_postmkvirtualenv -- virtualenvwrapper postmkvirtualenv
    # dotfiles_preactivate()    -- virtualenvwrapper preactivate
    # dotfiles_postactivate()   -- virtualenvwrapper postactivate
    # dotfiles_predeactivate()  -- virtualenvwrapper predeactivate
    # dotfiles_postdeactivate() -- virtualenvwrapper postdeactivate
   
   
#### etc/bash/06-bashrc.completion.sh
### bashrc.completion.sh
    # _configure_bash_completion()  -- configure bash completion
    #                               note: `complete -p` lists completions
   
   
#### etc/bash/07-bashrc.python.sh
### bashrc.python.sh
    # pypath()              -- print python sys.path and site config
    # _setup_python()       -- configure $PYTHONSTARTUP
    # _setup_pip()          -- set $PIP_REQUIRE_VIRTUALENV=false
## Pyenv
    # _setup_pyvenv()       -- set $PYENV_ROOT, add_to_path, and pyenv venvw
## Conda / Anaconda
    # _setup_anaconda()     -- set $ANACONDA_ROOT, add_to_path
    # workon_conda()        -- workon a conda + venv project
    # wec()                 -- workon a conda + venv project
    #                       note: tab-completion only shows regular virtualenvs
    # mkvirtualenv_conda()  -- mkvirtualenv and conda create
    # rmvirtualenv_conda()  -- rmvirtualenv conda
    #   TODO
    # mkvirtualenv_conda_if_available() -- mkvirtualenv_conda OR mkvirtualenv
    # workon_conda_if_available()       -- workon_conda OR we OR workon
   
   
#### etc/bash/07-bashrc.virtualenvwrapper.sh
### bashrc.virtualenvwrapper.sh
# sudo apt-get install virtualenvwrapper || sudo pip install virtualenvwrapper
    # _setup_virtualenvwrapper()    -- configure $VIRTUALENVWRAPPER_*
    # lsvirtualenvs()       -- list virtualenvs in $WORKON_HOME
    # lsve()                -- list virtualenvs in $WORKON_HOME
    # backup_virtualenv()   -- backup VIRTUAL_ENV_NAME $1 to [$2]
    # backup_virtualenvs()  -- backup all virtualenvs in $WORKON_HOME to [$1]
    # rebuild_virtualenv()      -- rebuild a virtualenv, leaving pkgs in place
    # rebuild_virtualenvs()     -- rebuild all virtualenvs in $WORKON_HOME
   
   
#### etc/bash/08-bashrc.gcloud.sh
### bashrc.gcloud.sh
    # _setup_google_cloud() -- configure gcloud $PATH and bash completions
   
   
#### etc/bash/10-bashrc.venv.sh
### bashrc.venv.sh
#   note: most of these aliases and functions are overwritten by `we` 
## Variables
    # __PROJECTSRC -- path to local project settings script
    # __SRC        -- path/symlink to local repository ($__SRC/hg $__SRC/git)
    # PATH="~/.local/bin:$PATH" (if not already there)
    # _VENV       -- path to local venv config script (executable)
## Functions
    # venv $@   -- call $_VENV $@
    # venv -h   -- print venv --help
    # venv -b   -- print bash configuration
    # venv -p   -- print IPython configuration as JSON
    # _venv <args> -- call $_VENV -E $@ (for the current environment)
    # we()         -- workon a virtualenv and load venv (TAB-completion)
    #  param $1: $VIRTUAL_ENV_NAME ("dotfiles")
    #  param $2: $_APP ("dotfiles") [default: $1)
    #   ${WORKON_HOME}/${VIRTUAL_ENV_NAME}  # == $VIRTUAL_ENV
    #   ${VIRTUAL_ENV}/src                  # == $_SRC
    #   ${_SRC}/${VIRTUAL_ENV_NAME}         # == $_WRD
    #  examples:
    #   we dotfiles
    #   we dotfiles dotfiles
## cd functions
    # cdb()     -- cd $_BIN
    # cde()     -- cd $_ETC
    # cdh()     -- cd $HOME
    # cdl()     -- cd $_LIB
    # cdlog()   -- cd $_LOG
    # cdp()     -- cd $PROJECT_HOME
    # cdph()    -- cd $PROJECT_HOME
    # cdpylib() -- cd $_PYLIB
    # cdpysite()-- cd $_PYSITE
    # cds()     -- cd $_SRC
    # cdv()     -- cd $VIRTUAL_ENV
    # cdve()    -- cd $WORKON_HOME
    # cdvar()   -- cd $_VAR
    # cdw()     -- cd $_WRD
    # cdwrd     -- cd $_WRD
    # cdwh      -- cd $WORKON_HOME
    # cdwrk()   -- cd $WORKON_HOME
    # cdww()    -- cd $_WWW
    # cdwww()   -- cd $_WWW
## Grin search
# virtualenv / virtualenvwrapper
    # grinv()   -- grin $VIRTUAL_ENV
    # grindv()  -- grind $VIRTUAL_ENV
# venv
    # grins()   -- grin $_SRC
    # grinds()  -- grind $_SRC
    # grinw()   -- grin $_WRD
    # grin-()   -- grin _WRD
    # grindw()  -- grind $_WRD
    # grind-()  -- grind $_WRD
    # grindctags()      -- generate ctags from grind (in ./tags)
    # grindctagssys()   -- generate ctags from grind --sys-path ($_WRD/tags)
    # grindctagsw()     -- generate ctags from (cd $_WRD; grind) ($_WRD/tags)
    # grindctagss()     -- generate ctags from (cd $_SRC; grind) ($_SRC/tags)
    # _load_venv_aliases()  -- load venv aliases
    #   note: these are overwritten by `we` [`source <(venv -b)`]
    # ssv()     -- supervisord   -c ${_SVCFG}
    # sv()      -- supervisorctl -c ${_SVCFG}
    # svd()     -- supervisorctl -c ${_SVCFG} restart && sv tail -f dev
    # svt()     -- supervisorctl -c "${_SVCFG}" tail -f
    # hgw()     -- hg -R  ${_WRD}
    # hg-()     -- hg -R  ${_WRD}
    # gitw()    -- git -C ${_WRD}
    # git-()    -- git -C ${_WRD}
    # serve-()  -- ${_SERVE_}
    # shell-()  -- ${_SHELL_}
    # test-()   -- cd ${_WRD} && python setup.py test
    # testr-()  -- reset; cd ${_WRD} && python setup.py test
    # makew()   -- cd $_WRD && make $@
    # make-()   -- cd $_WRD && make $@
    # mw()      -- cd $_WRD && make $@
    # _venv_set_prompt()    -- set PS1 with $WINDOW_TITLE, $VIRTUAL_ENV_NAME,
    #                          and ${debian_chroot}
    # _venv_ensure_paths()  -- create FSH paths in ${1} or ${VIRTUAL_ENV} 
   
   
#### etc/bash/11-bashrc.venv.pyramid.sh
### bashrc.venv.pyramid.sh
    # workon_pyramid_app()  -- $VIRTUAL_ENV_NAME [$_APP] [open_terminals]
   
   
#### etc/bash/20-bashrc.editor.sh
### bashrc.editor.sh
    # setup_editor()    -- configure ${EDITOR}
    #   VIMBIN  (str):   /usr/bin/vim
    #   GVIMBIN (str):   /usr/bin/gvim
    #   MVIMBIN (str):   /usr/local/bin/mvim
    #   GUIVIMBIN (str): $GVIMBIN || $MVIMBIN || ""
    #   EDITOR  (str):   $VIMBIN -f || $GUIVIMBIN -f
    #   EDITOR_ (str):   $EDITOR || $GUIVIMBIN $VIMCONF --remote-tab-silent
    #   VIMCONF (str):   --servername ${VIRTUAL_ENV_NAME:-'EDITOR'}
    #   SUDO_EDITOR (str): $EDITOR
    # ggvim()   -- ${EDITOR} $@ 2>&1 >/dev/null
    # edits()   -- open $@ in ${GUIVIMBIN} --servername $1
    # e()       -- ${EDITOR_} $@      [ --servername $VIRTUAL_ENV_NAME ]
    # edit()    -- ${EDITOR_} $@      [ --servername $VIRTUAL_ENV_NAME ]
    # editcfg() -- ${EDITOR_} ${_CFG} [ --servername $VIRTUAL_ENV_NAME ]
    # sudoe()   -- EDITOR=${SUDO_EDITOR} sudo -e
    # sudoe()   -- EDITOR=${SUDO_EDITOR} sudo -e
   
   
#### etc/bash/29-bashrc.vimpagers.sh
### bashrc.vimpagers.sh
    # _configure_lesspipe() -- (less <file.zip> | lessv)
    # vimpager() -- call vimpager
    # lessv()   -- less with less.vim and vim (g:tinyvim=1)
    # lessg()   -- less with less.vim and gvim / mvim
    # lesse()   -- less with current venv's vim server
    # manv()    -- view manpages in vim
    # mang()    -- view manpages in gvim / mvim
    # mane()    -- open manpage with venv's vim server
   
   
#### etc/bash/30-bashrc.usrlog.sh
### bashrc.usrlog.sh
    # _USRLOG (str): path to .usrlog userspace shell command log
    # stid()      -- set $TERM_ID to a random string
    # stid $name  -- set $TERM_ID to string
    # note()      -- add a dated note to $_USRLOG [_usrlog_append]
    # usrlogv()   -- open usrlog with vim:   $VIMBIN + $_USRLOG
    # usrlogg()   -- open usrlog with gmvim: $GUIVIMBIN + $_USRLOG
    # usrloge()   -- open usrlog with editor:$EDITOR + $_USRLOG
    # ut()        -- tail $_USRLOG
    # ug()        -- egrep current usrlog: egrep $@ $_USRLOG
    # ugall()     -- egrep $@ $__USRLOG ${WORKON_HOME}/*/.usrlog
    # ugrin()     -- grin current usrlog: grin $@ $_USRLOG
    # ugrinall()  -- grin $@  $__USRLOG ${WORKON_HOME}/*/.usrlog
    # lsusrlogs() -- ls -tr   $__USRLOG ${WORKON_HOME}/*/.usrlog
    # _setup_usrlog()   -- source ${__DOTFILES}/etc/usrlog.sh
    # usrlogv() -- open $_USRLOG w/ $VIMBIN (and skip to end)
    # usrlogg() -- open $_USRLOG w/ $GUIVIMBIN (and skip to end)
    # usrloge() -- open $_USRLOG w/ $EDITOR_ [ --servername $VIRTUAL_ENV_NAME ]
   
   
#### etc/bash/30-bashrc.xlck.sh
### 30-bashrc.xlck.sh
## xlck     -- minimal X screensaver
    # xlck 
    # xlck -I  --  (I)nstall xlck (apt-get)
    # xlck -U  --  check stat(U)s (show xautolock processes on this $DISPLAY)
    # xlck -S  --  (S)tart xlck (start xautolock on this $DISPLAY)
    # xlck -P  --  sto(P) xlck (stop xautolock on this $DISPLAY)
    # xlck -R  --  (R)estart xlck
    # xlck -M  --  suspend to ra(M) (and lock)
    # xlck -D  --  suspend to (D)isk (and lock)
    # xlck -L  --  (L)ock
    # xlck -X  --  shutdown -h now
    # xlck -h  --  help
    # xlck_status_all()             -- pgrep 'xautolock|xlock|i3lock', ps ufw
    # xlck_status_this_display()    -- show status for this $DISPLAY
    # _setup_xlck() -- source ${__DOTFILES}/etc/xlck.sh (if -z __IS_MAC)
   
   
#### etc/bash/40-bashrc.aliases.sh
### bashrc.aliases.sh
    #  _load_aliases()  -- load aliases
    # chmodr   -- 'chmod -R'
    # chownr   -- 'chown -R'
    # grep     -- 'grep --color=auto'
    # egrep    -- 'egrep --color=auto'
    # fgrep    -- 'fgrep --color=auto'
    # grindp   -- 'grind --sys.path'
    # grinp    -- 'grin --sys-path'
    # fumnt    -- 'fusermount -u'
    # ga       -- 'git add'
    # gl       -- 'git log --pretty=format:"%h : %an : %s" --topo-order --graph'
    # gs       -- 'git status'
    # gd       -- 'git diff'
    # gds      -- 'git diff -p --stat'
    # gc       -- 'git commit'
    # gco      -- 'git checkout'
    # gdc      -- 'git diff --cached'
    # gsl      -- 'git stash list'
    # gsn      -- 'git stash save'
    # gss      -- 'git stash save'
    # gitr     -- 'git remote -v'
    # hgl      -- 'hg glog --pager=yes'
    # hgs      -- 'hg status'
    # hgd      -- 'hg diff'
    # hgds     -- 'hg diff --stat'
    # hgdl     -- 'hg diff --color=always | less -R'
    # hgc      -- 'hg commit'
    # hgu      -- 'hg update'
    # hgq      -- 'hg qseries'
    # hgqd     -- 'hg qdiff'
    # hgqs     -- 'hg qseries'
    # hgqn     -- 'hg qnew'
    # hgr      -- 'hg paths'
    # __IS_MAC
        # la       -- 'ls -A -G'
        # ll       -- 'ls -alF -G'
        # ls       -- 'ls -G'
        # lt       -- 'ls -altr -G'
    # else
        # la       -- 'ls -A --color=auto'
        # ll       -- 'ls -alF --color=auto'
        # ls       -- 'ls --color=auto'
        # lt       -- 'ls -altr --color=auto'
    # __IS_LINUX
        # psx      -- 'ps uxaw'
        # psf      -- 'ps uxawf'
        # psxs     -- 'ps uxawf --sort=tty,ppid,pid'
        # psxh     -- 'ps uxawf --sort=tty,ppid,pid | head'
        # psh      -- 'ps uxaw | head'
        # psc      -- 'ps uxaw --sort=-pcpu'
        # psch     -- 'ps uxaw --sort=-pcpu | head'
        # psm      -- 'ps uxaw --sort=-pmem'
        # psmh     -- 'ps uxaw --sort=-pmem | head'
    # __IS_MAC
        # psx      -- 'ps uxaw'
        # psf      -- 'ps uxaw' # no -f
        # psh      -- 'ps uxaw | head'
        # psc      -- 'ps uxaw -c'
        # psch     -- 'ps uxaw -c | head'
        # psm      -- 'ps uxaw -m'
        # psmh     -- 'ps uxaw -m | head'
    # shtop    -- 'sudo htop'
    # t        -- 'tail'
    # tf       -- 'tail -f'
    # xclipc   -- 'xclip -selection c'
   
   
#### etc/bash/42-bashrc.commands.sh
### bashrc.commands.sh
# usage: bash -c 'source bashrc.commands.sh; funcname <args>'
    # chown-me()        -- chown -Rv user
    # chown-me-mine()   -- chown -Rv user:user && chmod -Rv go-rwx
    # chown-sme()       -- sudo chown -Rv user
    # chown-sme-mine()  -- sudo chown -Rv user:user && chmod -Rv go-rwx
    # chmod-unumask()   -- recursively add other+r (files) and other+rx (dirs)
    # new-sh()          -- create and open a new shell script at $1
    # diff-dirs()       -- list differences between directories
    # diff-stdin()      -- diff the output of two commands
    # wopen()           -- open path/URI/URL $1 in a new browser tab
    #                      see: scripts/x-www-browser
    # find-largefiles() -- find files larger than size (default: +10M)
    # find-pdf()        -- find pdfs and print info with pdfinfo
    # find-lately()     -- list and sort files in paths $@ by ISO8601 mtime
    #                      stderr > lately.$(date).errors
    #                      stdout > lately.$(date).files
    #                      stdout > lately.$(date).sorted
    #                      note: 
    # find-setuid()     -- find all setuid and setgid files
    #                      stderr > find-setuid.errors
    #                      stdout > find-setuid.files
    # find-startup()    -- find common startup files in common locations
    # find-ssl()        -- find .pem and .db files and print their metadata
    # find-dpkgfile()   -- search dpkgs with apt-file
    # find-dpkgfiles()  -- sort dpkg /var/lib/dpkg/info/<name>.list
    # deb-chksums()     -- check dpkg md5 checksums with md5sums
    # deb-mkrepo()      -- create dpkg Packages.gz and Sources.gz from dir ${1}
    # mnt-chroot-bind() -- bind mount linux chroot directories
    # mnt-cifs()        -- mount a CIFS mount
    # mnt-davfs()       -- mount a WebDAV mount
    # lsof-sh()         -- something like lsof
    # lsof-net()        -- lsof the network things
    # net-stat()        -- print networking information
    # ssh-prx()         -- SSH SOCKS
    # strace-()         -- strace with helpful options
    # strace-f()        -- strace -e trace=file + helpful options
    # strace-f-noeno()  -- strace -e trace=file | grep -v ENOENT
    # hgst()            -- hg diff --stat, hg status, hg diff
   
   
#### etc/bash/50-bashrc.bashmarks.sh
### bashrc.bashmarks.sh
## bashmarks
    # l()  -- list bashmarks
    # s()  -- save bashmarks as $1
    # g()  -- goto bashmark $1
    # p()  -- print bashmark $1
    # d()  -- delete bashmark $1
    # lsbashmarks() -- list Bashmarks (e.g. for NERDTree)
    # see also: ${__DOTFILES}/scripts/nerdtree_to_bashmarks.py
   
   
#### etc/bash/70-bashrc.repos.sh
### 70-bashrc.repos.sh
#
#
#
# Use Cases
# * Original: a bunch of commands that i was running frequently
#   before readthedocs (and hostthedocs)
# * local mirrors (manual, daily?)
#   * no internet, outages
#   * push -f
#   * (~offline) Puppet/Salt source installs
#     * bandwidth: testing a recipe that pulls a whole repositor(ies)
# * what's changed in <project>'s source dependencies, since i looked last
#
# Justification
# * very real risks for all development projects
#   * we just assume that GitHub etc. are immutable and forever
#
# Features (TODO) [see: pyrpo]
# * Hg <subcommands>
# * Git <subcommands>
# * Bzr <subcommands>
# * periodic backups / mirroring
# * gitweb / hgweb
# * mirror_and_backup <URL>
# * all changes since <date> for <set_of_hg-git-bzr-svn_repositories>
# * ideally: transparent proxy
#   * +1: easiest
#   * -1: pushing upstream
#
# Caveats
# * pasting / referencing links which are local paths
# * synchronization lag
# * duplication: $__SRC/hg/<pkg> AND $VIRTUAL_ENV/src/<pkg>
#
    #  setup_dotfiles_docs_venv -- create default 'docs' venv
    #  setup_dotfiles_src_venv -- create default 'src' venv
    #
    #   __SRC_HG=${WORKON_HOME}/src/src/hg
    #   __SRC_GIT=${WORKON_HOME}/src/src/git
    #
    #  Hg runs hg commands as user hg
    #  Git runs git commands as user git
    #
    #  Hgclone will mirror to $__SRC_HG
    #  Gitclone will mirror to $__SRC_GIT
    #
    #
# __SRC_GIT_REMOTE_URI_PREFIX   -- default git remote uri prefix
# __SRC_GIT_REMOTE_NAME         -- name for git remote v
# __SRC_HG_REMOTE_URI_PREFIX    -- default hg remote uri prefix
# __SRC_HG_REMOTE_NAME          -- name for hg paths
    ## Create a new hosted repository with gitolite-admin
    #  $1   -- repo [user/]name (e.g. westurner/dotfiles)
    ## push a git repository to local git storage
    #  $1   -- repo [user/]name (e.g. westurner/dotfiles) 
    #  $2   -- path of local repo (e.g. ~/wrk/.ve/dotfiles/src/dotfiles)
    ## Create a new hosted repository with mercurial-ssh
    ## push a hg repository to local git storage
    #  $1   -- repo [user/]name (e.g. westurner/dotfiles)
    #  $2   -- path of local repo (e.g. ~/wrk/.ve/dotfiles/src/dotfiles)
    #    fixperms ${path}
    #  host_docs    -- build and host documentation in a local directory
    #   param $1: <project_name>
    #   param $2: [<path>]
    #   param $3: [<docs/Makefile>]
    #   param $4: [<docs/conf.py>]
    # * log documentation builds
    # * build a sphinx documentation set with a Makefile and a conf.py
    # * rsync to docs webserver
    # * set permissions
    # this is not readthedocs.org
    # note: you must manually install packages into the
    # local 'docs' virtualenv'
                        # TODO: prompt?
        # >> 'html_theme = "_-_"
        # << 'html_theme = 'default'
   
   
#### etc/bash/99-bashrc.after.sh
   
   
